import { Given, When, Then } from '@cucumber/cucumber';
import * as playwright from '@playwright/test';
import { pageFixture, API_URL } from './hooks';

Given('I am on the {string} section', async (sectionName: string) => {
  await pageFixture.page.goto('/');
  await pageFixture.page.locator(`section#${sectionName.toLowerCase().replace(/ & /g, '-')}`).scrollIntoViewIfNeeded();
});

When('I click the {string} button', async (buttonName: string) => {
  await pageFixture.page.getByRole('button', { name: buttonName }).click();
});

When('I fill in the event form with:', async (dataTable: { rawTable: string[][] }) => {
  for (const row of dataTable.rawTable.slice(1)) {
    const [field, value] = row;
    await pageFixture.page.getByLabel(field).fill(value);
  }
});

When('I submit the form', async () => {
  await pageFixture.page.getByRole('button', { name: 'Save Event' }).click();
});

Then('I should see {string} added to the event list', async (eventName: string) => {
  // Wait for fetch/re-render
  await playwright.expect(pageFixture.page.getByText(eventName)).toBeVisible();
});

Then('I should see the role {string} displayed for the new event', async (role: string) => {
  await playwright.expect(pageFixture.page.getByText(role)).toBeVisible();
});

Then('the event form should be closed', async () => {
  await playwright.expect(pageFixture.page.getByRole('heading', { name: 'Add New Event' })).not.toBeVisible();
});

Then('I should not see {string} in the event list', async (eventName: string) => {
  await playwright.expect(pageFixture.page.getByText(eventName)).not.toBeVisible();
});

Given('there are more than {int} events available', async (count: number) => {
  const apiContext = await playwright.request.newContext({ baseURL: API_URL });
  // Current seed has 2 events. We need > 3. Add 2 more via API.
  for (let i = 1; i <= 2; i++) {
     await apiContext.post('events', {
         data: {
             title: `Extra Event ${i}`,
             role: 'Test Role',
             date: '2025-01-01',
             description: 'Generated by Test',
             tags: ['Test'],
             status: 'Upcoming'
         }
     });
  }
  await pageFixture.page.reload();
  await pageFixture.page.locator(`section#event`).scrollIntoViewIfNeeded();
});

When('I view the {string} section', async (sectionName: string) => {
  await pageFixture.page.locator(`section#${sectionName.toLowerCase().replace(/ & /g, '-')}`).scrollIntoViewIfNeeded();
});

Then('I should see exactly {int} events displayed', async (count: number) => {
  await playwright.expect(pageFixture.page.getByText('Loading events...')).not.toBeVisible();
  await playwright.expect(pageFixture.page.locator('[data-testid="event-item"]')).toHaveCount(count);
});

Then('I should see a {string} button', async (buttonName: string) => {
  await playwright.expect(pageFixture.page.getByRole('button', { name: buttonName })).toBeVisible();
});

Then('I should see a list of existing events', async () => {
  await playwright.expect(pageFixture.page.getByText('Loading events...')).not.toBeVisible();
  await playwright.expect(pageFixture.page.locator('[data-testid="event-item"]')).not.toHaveCount(0);
});

Then('I should see event details like {string}', async (text: string) => {
  await playwright.expect(pageFixture.page.getByText(text, { exact: true })).toBeVisible();
});

Then('I should not see the 4th event or subsequent events directly in the list', async () => {
  const count = await pageFixture.page.locator('[data-testid="event-item"]').count();
  playwright.expect(count).toBe(3);
});
